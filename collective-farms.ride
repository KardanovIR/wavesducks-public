{-# STDLIB_VERSION 5 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

let mAccPKey = base58'23NWm7kUDQqbTVkirjd5JXWRZaWVoS4ZesmRNHicBa3T'
let mAccAddr = mAccPKey.addressFromPublicKey()
let feePercent = getIntegerValue(mAccAddr, "f_" + this.toString() + "_fee")


let kTotalLiquidity = "total_liquidity"
let kInitialized = "INITIALIZED"
let kLiquidityThreshold = "LIQUIDITY_THRESHOLD"
let kFarmParticipants = "farm_participants"
let kTotalShareTokens = "total_share_tokens"
let kShareAssetId = "SHARE_ASSET_ID"
let kIncubatorDapp = "INCUBATOR_DAPP"
let kBreederDapp = "BREEDER_DAPP"
let kFarmingDapp = "FARMING_DAPP"
let kMarketProxyDapp = "MARKETPLACE_PROXY_DAPP"
let kAuctionDapp = "AUCTION_DAPP"
let kLocked = "LOCKED"
let kTotalFarmingReward = "total_farming_reward"
let kCeoCollectedFee = "ceo_collected_fee"
let kCeoCollectedFeeOverall = "ceo_fee_overall"
let kToDistr = "to_distribute"

func getInt(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
     case _ => 0
  }
}

func getStr(key: String) = {
  match getString(this, key) {
      case b:String => b
      case _ => ""
  }
}

func getBool(key: String) = {
  match getBoolean(this, key) {
      case b:Boolean => b
      case _ => unit
  }
}

func getStrA(a: Address, k: String) = {
  match getString(a, k) {
      case b:String => b
      case _ => ""
  }
}

func getIntA(address: Address, key: String) = {
    match getInteger(address, key) {
        case b:Int => b
        case _ => 0
    }
}

func getMarketProxyAddr() = {
  getStrA(mAccAddr, kMarketProxyDapp)
}

func getEggId() = {
  getStringValue(mAccAddr, "EGG_ASSET_ID").fromBase58String()
}
func getShareAssetId() = {
  getStr(kShareAssetId).fromBase58String()
}

@Callable(i)
func initCollectiveFarm(name: String, minimumThreshold: Int) = {
  if (i.callerPublicKey != mAccPKey) then {
      throw("_1")
  }else if (getBool(kInitialized) != unit) then {
      throw("_2")
  } else if (i.payments[0].amount != 10 || i.payments[0].assetId != getEggId()) then {
      throw("_20")
  } else {
      let shareTokens = 1_0_000_000
      let shareToken = Issue(name, "Share token for the \"" + name + "\" collective farm", shareTokens, 8, true)
      
      [
        StringEntry(kShareAssetId, shareToken.calculateAssetId().toBase58String()),
        BooleanEntry(kInitialized, true),
        IntegerEntry(kTotalLiquidity, 10),
        IntegerEntry(kTotalShareTokens, shareTokens),
        shareToken,
        ScriptTransfer(i.caller, shareTokens, shareToken.calculateAssetId()),
        BooleanEntry(kLocked, false),
        IntegerEntry(kLiquidityThreshold, minimumThreshold)
      ]
  }
}

@Callable(i)
func setLock(s: Boolean) = {
  if (i.callerPublicKey != mAccPKey) then {
    throw("_21")
  } else {
      [
        BooleanEntry(kLocked, s)
      ]
  }
}

@Callable(i)
func provideLiquidity() = {
  let eggAssetId = getEggId()
  if (getBool(kLocked) == true) then throw("_22") else
  if (i.payments[0].assetId != eggAssetId) then {
    throw("_4")
  } else {
    let totalLiquidity = getInt(kTotalLiquidity)
    let totalShareTokens = getInt(kTotalShareTokens)
    let currentLiquidityAmount = i.payments[0].amount
    let shareTokensToGive = currentLiquidityAmount * 1_000_000 # decimals difference

    let shareTokensId = getStr(kShareAssetId).fromBase58String()

    let reissue = Reissue(getShareAssetId(), shareTokensToGive, true)
    let farmParticipants = getInt(kFarmParticipants)
    let kParticipated = "account_" + i.caller.toString() + "_participated"
    let alreadyParticipated = getBool(kParticipated)
    let newFarmParticipants = if (alreadyParticipated == unit) then farmParticipants + 1 else farmParticipants

    [
      reissue,
      ScriptTransfer(i.caller, shareTokensToGive, shareTokensId),
      IntegerEntry(kTotalShareTokens, totalShareTokens + shareTokensToGive),
      IntegerEntry(kTotalLiquidity, totalLiquidity + i.payments[0].amount.value()),
      IntegerEntry(kFarmParticipants, newFarmParticipants),
      BooleanEntry(kParticipated, true)
    ]
  }
}


@Callable(i)
func claimFarmingRewardProxy(ids: String) = {
  if (i.callerPublicKey != mAccPKey) then throw("_23")
  else {
    let farmingDapp = getStrA(mAccAddr, kFarmingDapp).addressFromStringValue()

    func claimReward(accum: Int, nftId: String) = {
      strict invRes = invoke(farmingDapp, "claimReward", [nftId], [])
      match invRes {
        case int: Int => accum + int
        case _ => throw("_5")
      }
    }

    let nftIds = ids.split(";")
    let foldResult = FOLD<30>(nftIds, 0, claimReward)
    let claimedReward = match foldResult {
      case int: Int => int
      case _ => throw("_6")
    }
    let farmCeoFeeSize = fraction(claimedReward, feePercent, 100)

    let toDistr = getInt(kToDistr)
    let totalFarmingReward = getInt(kTotalFarmingReward)
    let currentCeoFee = getInt(kCeoCollectedFee)
    let ceoFeeOverall = getInt(kCeoCollectedFeeOverall)

    [
      IntegerEntry(kTotalFarmingReward, totalFarmingReward + claimedReward - farmCeoFeeSize),
      IntegerEntry(kCeoCollectedFee, currentCeoFee + farmCeoFeeSize),
      IntegerEntry(kToDistr, toDistr + claimedReward - farmCeoFeeSize),
      IntegerEntry(kCeoCollectedFeeOverall, ceoFeeOverall + farmCeoFeeSize)
    ]
  }
}

@Callable(i)
func claimCeoFee(address: String) = {
  if (getBool(kLocked) == true) then throw("_22") else
  if (i.caller == this) then {
    let currentCeoCollectedFee = getInt(kCeoCollectedFee)
    [
      ScriptTransfer(address.addressFromStringValue(), currentCeoCollectedFee, getEggId()),
      IntegerEntry(kCeoCollectedFee, 0)
    ]
  } else throw("_8")
}

@Callable(i)
func startLiquidation(auctionId: String) = {
  throw("_7")
}

@Callable(i)
func voteForLiquidation(auctionId: String) = {
  throw("_7")
}


@Verifier(tx)
func verify() = {
  let checkStarted = getInt(kTotalLiquidity) >= getInt(kLiquidityThreshold)

  func totalEggSpending(accum: Int, payment: AttachedPayment) = {
    if (payment.assetId == getEggId()) then accum + payment.amount else accum
  }

  match (tx) {
      case inv:InvokeScriptTransaction => {
        let toDistr = getInt(kToDistr)

        # Avoid scam with high fees => allow only Waves and minimal amount

        if (sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey) == false) then throw("_100") else
        if (checkStarted == false) then throw("_14") else
        if (getBool(kLocked) == true) then throw("_22") else
        if (inv.fee > 900000 || inv.feeAssetId != unit) then {
          throw("_15")
        }else if (inv.function == "claimReward") then {
          throw("_16")
        } else if (inv.payments.size() > 2) then {
          throw("_17")
        } else if ((assetBalance(this, getEggId()) - FOLD<3>(inv.payments, 0, totalEggSpending)) < toDistr) then {
          throw("_18=" + toDistr.toString())
        } else if (inv.dApp.addressFromRecipient() == this && inv.function == "claimCeoFee") then {
          sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        } else if (inv.dApp.addressFromRecipient() == getMarketProxyAddr().addressFromStringValue() && inv.function == "callMarketplaceProxy") then {
          sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        } else {
          let allowedContracts = getStrA(mAccAddr, "allowed_contracts")
          let allowedContractsList = allowedContracts.split(";")
          let dappToCall = inv.dApp.addressFromRecipient().toString()
          allowedContractsList.indexOf(dappToCall) != unit
        }
      }
      case ss: SetScriptTransaction => {
        sigVerify(tx.bodyBytes, tx.proofs[0], mAccPKey)
      }
      case _ => false
    }
}
