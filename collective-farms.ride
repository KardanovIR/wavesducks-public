{-# STDLIB_VERSION 5 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

let mAccPKey = base58'23NWm7kUDQqbTVkirjd5JXWRZaWVoS4ZesmRNHicBa3T'
let mAccAddr = mAccPKey.addressFromPublicKey()
let redeployPubKey = base58''
let feePercent = getIntegerValue(mAccAddr, "f_" + this.toString() + "_fee")


let kTotalLiquidity = "total_liquidity"
let kInitialized = "INITIALIZED"
let kLiquidityThreshold = "LIQUIDITY_THRESHOLD"
let kTotalShareTokens = "total_share_tokens"
let kShareAssetId = "SHARE_ASSET_ID"
let kIncubatorDapp = "INCUBATOR_DAPP"
let kBreederDapp = "BREEDER_DAPP"
let kFarmingDapp = "FARMING_DAPP"
let kMarketDapp = "MARKETPLACE_DAPP"
let kLocked = "LOCKED"
let kTotalFarmingReward = "total_farming_reward"
let kCeoCollectedFee = "ceo_collected_fee"
let kCeoCollectedFeeOverall = "ceo_fee_overall"
let kToDistr = "to_distribute"

func getInt(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
     case _ => 0
  }
}

func getStr(key: String) = {
  match getString(this, key) {
      case b:String => b
      case _ => ""
  }
}

func getBool(key: String) = {
  match getBoolean(this, key) {
      case b:Boolean => b
      case _ => unit
  }
}

func getStrA(a: Address, k: String) = {
  match getString(a, k) {
      case b:String => b
      case _ => ""
  }
}

func getIntA(address: Address, key: String) = {
    match getInteger(address, key) {
        case b:Int => b
        case _ => 0
    }
}

func getMarketAddr() = {
  getStrA(mAccAddr, kMarketDapp)
}

func amountOrClear(amount: String) = {
  if (amount.contains("0")) then {""} else {amount}
}

func isSymbolA(acc: Int, sym: String) = { if (sym == "A") then {acc+1} else {acc+0} }
func isSymbolB(acc: Int, sym: String) = { if (sym == "B") then {acc+1} else {acc+0} }
func isSymbolC(acc: Int, sym: String) = { if (sym == "C") then {acc+1} else {acc+0} }
func isSymbolD(acc: Int, sym: String) = { if (sym == "D") then {acc+1} else {acc+0} }
func isSymbolE(acc: Int, sym: String) = { if (sym == "E") then {acc+1} else {acc+0} }
func isSymbolF(acc: Int, sym: String) = { if (sym == "F") then {acc+1} else {acc+0} }
func isSymbolG(acc: Int, sym: String) = { if (sym == "G") then {acc+1} else {acc+0} }
func isSymbolH(acc: Int, sym: String) = { if (sym == "H") then {acc+1} else {acc+0} }

func getGen(assetName: String) = {
  # getGen("DUCK-ABCDDCBA-GY") -> 2A2B2C2D-G
  let geno = assetName.drop(5).dropRight(3).split("")
  amountOrClear(toString(FOLD<8>(geno, 0, isSymbolA)) + "A") + amountOrClear(toString(FOLD<8>(geno, 0, isSymbolB)) + "B") + amountOrClear(toString(FOLD<8>(geno, 0, isSymbolC)) + "C") +
  amountOrClear(toString(FOLD<8>(geno, 0, isSymbolD)) + "D") + amountOrClear(toString(FOLD<8>(geno, 0, isSymbolE)) + "E") + amountOrClear(toString(FOLD<8>(geno, 0, isSymbolF)) + "F") +
  amountOrClear(toString(FOLD<8>(geno, 0, isSymbolG)) + "G") + amountOrClear(toString(FOLD<8>(geno, 0, isSymbolH)) + "H")
}


func getAssetOrigin(generation: String) = {
  let incubatorAddress = getStrA(mAccAddr, kIncubatorDapp)
  let breederAddress = getStrA(mAccAddr, kBreederDapp)

  if (generation == "G") then {incubatorAddress.fromBase58String()} else {breederAddress.fromBase58String()}
}

func getAssetRarity(geno: String, generation: String) = {
  let quantity = getIntegerValue(Address(getAssetOrigin(generation)), "stats_"+geno+"_quantity")
  let power = pow(10000 / quantity, 4, 5, 1, 2, FLOOR)
  if (power > 0) then {power} else {2}
}

func getAssetFarmingPower(assetId: ByteVector) = {
  let breederAddress = getStrA(mAccAddr, kBreederDapp).fromBase58String()
  let incubatorAddress = getStrA(mAccAddr, kIncubatorDapp).fromBase58String()
  
  if (assetInfo(assetId).value().issuer == Address(breederAddress) || assetInfo(assetId).value().issuer == Address(incubatorAddress)) then {
    let assetName = assetInfo(assetId).value().name
    let generation = assetName.takeRight(2).take(1)
    let gen = getGen(assetName) + "-" + generation
    getAssetRarity(gen, generation)
  } else {
    throw("_20")
  }
}

func getDuckMarketPrice(nftId: ByteVector) = {
  let rarity = getAssetFarmingPower(nftId)
  let breederAddress = getStrA(mAccAddr, kBreederDapp).addressFromStringValue()
  let canBreed = getIntA(breederAddress, "asset_" + nftId.toBase58String() + "_children")
  let canBreedText = if canBreed > 0 then "1" else "0"
  let val = getInteger(mAccAddr, "r-" + rarity.toString() + "-b-" + canBreedText)
  val.valueOrErrorMessage("There is no oracle data for this type of duck")
}

func getDuckIdByAuctionId(auctionId: String) = {
  let marketAddr = getMarketAddr()
  getStrA(marketAddr.addressFromStringValue(), "auction_" + auctionId + "_assetId")
}

func getBidAmount(auctionId: String, bidId: String) = {
  let marketAddr = getMarketAddr()
  getIntA(marketAddr.addressFromStringValue(), "auction_" + auctionId + "_bid_" + bidId + "_amount")
}

func getEggId() = {
  getStringValue(mAccAddr, "EGG_ASSET_ID").fromBase58String()
}
func getShareAssetId() = {
  getStr(kShareAssetId).fromBase58String()
}

@Callable(i)
func initCollectiveFarm(name: String, minimumThreshold: Int) = {
  if (i.callerPublicKey != mAccPKey) then {
      throw("_1")
  }else if (getBool(kInitialized) != unit) then {
      throw("_2")
  } else if (i.payments[0].amount != 10 || i.payments[0].assetId != getEggId()) then {
      throw("_20")
  } else {
      let shareTokens = 1_0_000_000
      let shareToken = Issue(name, "Share token for the \"" + name + "\" collective farm", shareTokens, 8, true)
      
      [
        StringEntry(kShareAssetId, shareToken.calculateAssetId().toBase58String()),
        BooleanEntry(kInitialized, true),
        IntegerEntry(kTotalLiquidity, 10),
        IntegerEntry(kTotalShareTokens, shareTokens),
        shareToken,
        ScriptTransfer(i.caller, shareTokens, shareToken.calculateAssetId()),
        BooleanEntry(kLocked, false),
        IntegerEntry(kLiquidityThreshold, minimumThreshold)
      ]
  }
}

@Callable(i)
func setLock(s: Boolean) = {
  if (i.callerPublicKey != mAccPKey) then {
    throw("_21")
  } else {
      [
        BooleanEntry(kLocked, s)
      ]
  }
}

@Callable(i)
func provideLiquidity() = {
  let eggAssetId = getEggId()
  if (getBool(kLocked) == true) then throw("_22") else
  if (i.payments[0].assetId != eggAssetId) then {
    throw("_4")
  } else {
    let totalLiquidity = getInt(kTotalLiquidity)
    let totalShareTokens = getInt(kTotalShareTokens)
    let currentLiquidityAmount = i.payments[0].amount
    let shareTokensToGive = currentLiquidityAmount * 1_000_000 # decimals difference

    let shareTokensId = getStr(kShareAssetId).fromBase58String()

    let reissue = Reissue(getShareAssetId(), shareTokensToGive, true)

    [
      reissue,
      ScriptTransfer(i.caller, shareTokensToGive, shareTokensId),
      IntegerEntry(kTotalShareTokens, totalShareTokens + shareTokensToGive),
      IntegerEntry(kTotalLiquidity, totalLiquidity + i.payments[0].amount.value())
    ]
  }
}


@Callable(i)
func claimFarmingRewardProxy(ids: String) = {
  if (i.callerPublicKey != mAccPKey) then throw("_23")
  else {
    let farmingDapp = getStrA(mAccAddr, kFarmingDapp).addressFromStringValue()

    func claimReward(accum: Int, nftId: String) = {
      strict invRes = invoke(farmingDapp, "claimReward", [nftId], [])
      match invRes {
        case int: Int => accum + int
        case _ => throw("_5")
      }
    }

    let nftIds = ids.split(";")
    let foldResult = FOLD<30>(nftIds, 0, claimReward)
    let claimedReward = match foldResult {
      case int: Int => int
      case _ => throw("_6")
    }
    let farmCeoFeeSize = fraction(claimedReward, feePercent, 100)

    let toDistr = getInt(kToDistr)
    let totalFarmingReward = getInt(kTotalFarmingReward)
    let currentCeoFee = getInt(kCeoCollectedFee)
    let ceoFeeOverall = getInt(kCeoCollectedFeeOverall)

    [
      IntegerEntry(kTotalFarmingReward, totalFarmingReward + claimedReward - farmCeoFeeSize),
      IntegerEntry(kCeoCollectedFee, currentCeoFee + farmCeoFeeSize),
      IntegerEntry(kToDistr, toDistr + claimedReward - farmCeoFeeSize),
      IntegerEntry(kCeoCollectedFeeOverall, ceoFeeOverall + farmCeoFeeSize)
    ]
  }
}

@Callable(i)
func claimCeoFee(address: String) = {
  if (getBool(kLocked) == true) then throw("_22") else
  if (i.caller == this) then {
    let currentCeoCollectedFee = getInt(kCeoCollectedFee)
    [
      ScriptTransfer(address.addressFromStringValue(), currentCeoCollectedFee, getEggId()),
      IntegerEntry(kCeoCollectedFee, 0)
    ]
  } else throw("_8")
}

@Callable(i)
func startLiquidation(auctionId: String) = {
  throw("_7")
}

@Callable(i)
func voteForLiquidation(auctionId: String) = {
  throw("_7")
}


@Verifier(tx)
func verify() = {
  let checkStarted = getInt(kTotalLiquidity) >= getInt(kLiquidityThreshold)

  func totalEggSpending(accum: Int, payment: AttachedPayment) = {
    if (payment.assetId == getEggId()) then accum + payment.amount else accum
  }

  if (checkStarted == false) then throw("_14") else
  if (getBool(kLocked) == true) then throw("_22") else
  match (tx) {
      case inv:InvokeScriptTransaction => {
        let toDistr = getInt(kToDistr)

        # Avoid scam with high fees => allow only Waves and minimal amount
        if (inv.fee > 900000 || inv.feeAssetId != unit) then {
          throw("_15")
        }else if (inv.function == "claimReward") then {
          throw("_16")
        } else if (inv.payments.size() > 2) then {
          throw("_17")
        } else if ((assetBalance(this, getEggId()) - FOLD<3>(inv.payments, 0, totalEggSpending)) < toDistr) then {
          throw("_18=" + toDistr.toString())
        } else if (inv.dApp.addressFromRecipient() == this && inv.function == "claimCeoFee") then {
          true
        } else if (inv.dApp.addressFromRecipient() == this && inv.function == "callMarketplaceProxy") then {
          true
        } else {
          let allowedContracts = getStrA(mAccAddr, "allowed_contracts")
          let marketAddr = getMarketAddr()
          let allowedContractsList = allowedContracts.split(";")
          let dappToCall = inv.dApp.addressFromRecipient().toString()
          # limit duck buy/sell parameters
          if (dappToCall == marketAddr) then {
            throw("_19")
          # allow to call only contracts from the white-list (duck contracts + swop.fi)
          } else allowedContractsList.indexOf(dappToCall) != unit
        }
      }
      case ss: SetScriptTransaction => {
        sigVerify(tx.bodyBytes, tx.proofs[0], mAccPKey)
      }
      case _ => false
    }
}
