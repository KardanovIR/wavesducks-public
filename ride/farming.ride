{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


let perchPrice = 100 * 1000000
let scale = 10000
let scale2 = 1000000


func tryGetStringExternal(address: Address, key: String) = {
    match getString(address, key) {
        case a:String => a
        case _ => ""
    }
}


func tryGetString(key: String) = {
    tryGetStringExternal(this,key)
}

func getOracle() = Address(tryGetString("static_oracleAddress").fromBase58String())

func getEggAssetId() = tryGetStringExternal(getOracle(),"static_eggAssetId").fromBase58String() #base58'C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS'
func getIncubatorAddress() =  Address(tryGetStringExternal(getOracle(),"static_incubatorAddress").fromBase58String()) #base58'3PEktVux2RhchSN63DsDo4b4mz4QqzKSeDv'
func getRebirthAddress() =  Address(tryGetStringExternal(getOracle(),"static_rebirthAddress").fromBase58String()) #base58'3PCC6fVHNa6289DTDmcUo3RuLaFmteZZsmQ'
func getSwopPromoAddress() =  Address(tryGetStringExternal(getOracle(),"static_swopPromoAddress").fromBase58String()) #base58'3P6s9C39Ak5FAQ3F5VapYJ3ULxgbsAReXWD'
func getBreederAddress() =  Address(tryGetStringExternal(getOracle(),"static_breederAddress").fromBase58String()) #base58'3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb'
func getRefContractAddress() =  Address(tryGetStringExternal(getOracle(),"static_refContractAddress").fromBase58String()) #base58'3P8ejTkfRpz9WqCwCuihesNXU5k3zmFFfVe'
func getItemsAddress() =  Address(tryGetStringExternal(getOracle(),"static_itemsAddress").fromBase58String())
func getAccBoosterAddress() =  Address(tryGetStringExternal(getOracle(),"static_accBoosterAddress").fromBase58String())
func getTrustedContracts() =  tryGetStringExternal(getOracle(),"static_trustedContracts")


let RefererReward = 5 #percentage



func getRewardPerBlock() = {
  684 # 0.0684 EGGs per block
}

func isLocked() = {
  let masterAddress = Address(base58'3PEPftf2kWZDmAaWBjs6BUJa9957kiA2PkU')
  match getInteger(masterAddress, "egglock") {
        case b:Int => b
        case _ => 0
    }
}

func tryGetInteger(key: String) = {
    match getInteger(this, key) {
        case b:Int => b
        case _ => 0
    }
}

func tryGetBoolean(key: String) = {
    match getBoolean(this, key) {
        case b:Boolean => b
        case _ => false
    }
}

func isUserBlacklisted(address: String) = {
  false
  # let k = getBoolean(Address(base58'3PAHCfc8ZAwJ26bB32YK6ZNVTVBpgVnGTNc'), "locked_"+address+"_status")
  # match k {
  #   case k:Boolean => k 
  #   case _ => false
  # }
}

func getAssetOrigin(generation: String) = {
  if (generation == "G") then {getIncubatorAddress()} else {getBreederAddress()}
}

#TODO: count in items in calculating staking power
func getAssetRarity(genotype: String, generation: String) = {
  let quantity = valueOrErrorMessage(getInteger(getAssetOrigin(generation), "stats_"+genotype+"_quantity"),"stats_"+genotype+"_quantity not found")
  let power = pow(10000 / quantity, 4, 5, 1, 2, FLOOR)
  if (power > 0) then {power} else {2}
}

func asString(value: Any) = match value {
  case string: String => string
  case _ => throw("wrong type, expected: String")
}

func asInt(value: Any) = match value {
  case int: Int => int
  case _ => throw("wrong type, expected: Int")
}

func getAssetFarmingPower(assetId: ByteVector, address: String) = {
  if (assetInfo(assetId).value().issuer == getBreederAddress() || assetInfo(assetId).value().issuer == getIncubatorAddress()) then {
    let assetName = assetInfo(assetId).value().name
    let generation = assetName.takeRight(2).take(1)
    strict farmGen = invoke(getBreederAddress(),"getGenFromName",[assetName],[]).asString()
    strict farmBoost = invoke(getItemsAddress(),"calculateFarmingPowerBoost",[assetId.toBase58String(),address],[]).asInt()
    let rarity = getAssetRarity(farmGen, generation)
    let totalFarmingPower = rarity + fraction(rarity,farmBoost,100)
    (farmGen, totalFarmingPower )
  } else {
    throw("not valid NFT")
  }
}

func getLastKnownAssetFarmingPower(address: String, assetId: String) = {
  tryGetInteger("address_"+address+"_asset_"+assetId+"_farmingPower")
}

func getAssetsByGen(gen: String) = {
  let s = tryGetString("assets_"+gen)
  if (s == "") then {[]} else {s.split(",")}
}

func calcInterest(previousInterest: Int, previousInterestHeight: Int, totalFarmingPower: Int) = {
  # interest = amount of EGGlets you would earn if staked 1 percent of farming power since the very first block of farming
  previousInterest + scale * getRewardPerBlock() * (height-previousInterestHeight) / totalFarmingPower
}

func getCurrentInterest() = {
  if (tryGetInteger("total_farmingPower") > 0) then {
    let previousInterest = tryGetInteger("total_lastCheckInterest")
    let previousInterestHeight = tryGetInteger("total_lastCheckInterestHeight")
    let totalFarmingPower = tryGetInteger("total_farmingPower")

    calcInterest(previousInterest, previousInterestHeight, totalFarmingPower)
  } else if (tryGetInteger("total_startHeight") != 0) then { tryGetInteger("total_lastCheckInterest") } else { throw("farming is not launched, yet") }
}


func calcAssetRewardDelta(address: String, assetId: String, assetFarmingPower: Int) = {
  let lastCheckAssetInterest = tryGetInteger("address_"+address+"_asset_"+assetId+"_lastCheckInterest")
  let currentInterest = getCurrentInterest()

  assetFarmingPower * (currentInterest - lastCheckAssetInterest)
}


func addAssetIdToGenEntry(assetId: String, assetGen: String) = {
  let currentValue = tryGetString("assets_"+assetGen+"_locked")
  if (currentValue == "") then {assetId} else {currentValue+","+assetId}
}


func getStakeResult(address: String, assetId: ByteVector, assetFarmingPower: Int, unstaker: String) = {
  let asset = assetId.toBase58String()
  [
    IntegerEntry("total_farmingPower", tryGetInteger("total_farmingPower") + assetFarmingPower),
    IntegerEntry("total_lastCheckInterest", getCurrentInterest()),
    IntegerEntry("total_lastCheckInterestHeight", height),
    IntegerEntry("address_"+address+"_asset_"+asset+"_farmingPower", assetFarmingPower),
    IntegerEntry("address_"+address+"_asset_"+asset+"_lastCheckInterest", getCurrentInterest()),
    StringEntry("address_"+address+"_asset_"+asset+"_unstaker",unstaker)
  ]
}

func getUnstakeResult(address: String, assetId: ByteVector, rewardDelta: Int, withdrawnAmount: Int, assetFarmingPower: Int) = {
  let asset = assetId.toBase58String()
  [
    IntegerEntry("total_farmingPower", tryGetInteger("total_farmingPower") - assetFarmingPower),
    IntegerEntry("total_lastCheckInterest", getCurrentInterest()),
    IntegerEntry("total_lastCheckInterestHeight", height),
    IntegerEntry("address_"+address+"_asset_"+asset+"_farmingPower", 0),
    IntegerEntry("address_"+address+"_asset_"+asset+"_lastCheckInterest", getCurrentInterest()),
    IntegerEntry("address_"+address+"_asset_"+asset+"_withdrawnAmount", tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount") + withdrawnAmount * scale2),
    IntegerEntry("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount", tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount") + rewardDelta)
  ]
}

func calculatePerchPrice(address: String)= {
  let hasArtefactStaked = tryGetStringExternal(getAccBoosterAddress(),"ART-XMISTL_" + address + "_owner")
  if hasArtefactStaked == ""
  then
    perchPrice
  else
    perchPrice/10*9

}

@Callable(i)
func configureOracle(oracle: String) = {
  if i.caller != this then throw("admin only") else 
  [
    StringEntry("static_oracleAddress",oracle)
  ]

}

@Callable(i)
func init() = {
  if (i.caller != this) then { throw("admin only") } else {
    [ IntegerEntry("total_startHeight", height) ]
  }
}

@Callable(i)
func buyPerch(color: String, refererAddress: String) = {
  # throw("under maintence")
  if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    if (["B", "R", "G", "Y"].indexOf(color).value() < 0) then {
      throw("you need to set color properly")
    } else {
      let firstPayment = i.payments[0].value()
      let exactPrice = calculatePerchPrice(i.caller.toString())
      if (firstPayment.assetId != getEggAssetId()) then throw("You can attach only EGG tokens with the following asset id: " + getEggAssetId().toBase58String())
      else if (firstPayment.amount != exactPrice) then throw("To buy a perch you currently need the following amount of EGGlets: " + exactPrice.toString())
      else {
        let refererRewardForPerch = fraction(firstPayment.amount, RefererReward, 100)

        strict refCall = invoke(getRefContractAddress(), "refPayment",
        [refererAddress], [AttachedPayment(getEggAssetId(), refererRewardForPerch)])

        let perchAmountKey = "address_" + i.caller.toString() + "_perchesAvailable_" + color
        let perchAmount = tryGetInteger(perchAmountKey)
        [
          IntegerEntry(perchAmountKey, perchAmount + 1)
        ]
      }
    }
  }
}

@Callable(i)
func addFreePerch(address: String, color: String) = {
  if (["B", "R", "G", "Y"].indexOf(color).value() < 0) then {
    throw("you need to set color properly")
  } else if (i.caller != getRebirthAddress() && i.caller != this && i.caller != getSwopPromoAddress()) then {
    throw("rebirth and swop promo only")
  } else {
    let perchAmountKey = "address_" + address + "_perchesAvailable_" + color
    let perchAmount = tryGetInteger(perchAmountKey)
    ([
      IntegerEntry(perchAmountKey, perchAmount + 1)
    ], "")
  }
}

@Callable(i)
func stakeNFT() = {
  # throw("under maintence")
  if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let pmt = i.payments[0].value()
    let assetId = i.payments[0].value().assetId.value()
    let address = i.originCaller.toString()

    let color = assetInfo(assetId).value().name.takeRight(1)
    let availablePerches = tryGetInteger("address_"+address+"_perchesAvailable_"+color)

    if (pmt.amount != 1) then throw("NFT is not attached") else
    if (availablePerches <= 0) then {
      throw("no perches available for the color " + color)
    } else {
      let (assetGen, assetFarmingPower) = getAssetFarmingPower(assetId,address)

      let realCaller = i.caller.toString()

      getStakeResult(address, assetId, assetFarmingPower, realCaller) ++ [
        IntegerEntry("address_"+address+"_perchesAvailable_"+color, availablePerches - 1)
      ]
    }
  }  
}

@Callable(i)
func stakeNFTWithoutPerch() = {
  let allowedContracts = getTrustedContracts()
  let allowedContractsList = allowedContracts.split(";")
  let dappToCall = i.caller.toString()
  if allowedContractsList.indexOf(dappToCall) == unit then throw("Only trusted smart contracts can stake without a perch!") else
  if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let pmt = i.payments[0].value()
    let assetId = i.payments[0].value().assetId.value()
    let address = i.originCaller.toString()

    if (pmt.amount != 1) then throw("NFT is not attached") else
    let (assetGen, assetFarmingPower) = getAssetFarmingPower(assetId,address)
    let asset = assetId.toBase58String()

    let realCaller = i.caller.toString()

    getStakeResult(address, assetId, assetFarmingPower, realCaller) ++ [
      BooleanEntry("address_"+address+"_asset_"+asset+"_without_perch", true)
      ]
  }  
}

@Callable(i)
func unstakeNFT(asset: String) = {
  # throw("under maintence")
  let address = i.originCaller.toString()
  if (isUserBlacklisted(address)) then {
    throw("Ooops, looks like you lost in one of the Ducksquid games! As you already know, any loss has its consequences, so you will be not able to claim your farming rewards till the end of DuckSquid game. Quack in peace!")
  } else if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let assetId = asset.fromBase58String()
    

    let assetFarmingPower = getLastKnownAssetFarmingPower(address, asset)
    let assetRewardDelta = calcAssetRewardDelta(address, asset, assetFarmingPower)

    let farmedAmount = assetRewardDelta + tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount")
    let withdrawnAmount = tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount")

    let reward = (farmedAmount - withdrawnAmount) / (scale * 100)

    let color = assetInfo(assetId).value().name.takeRight(1)
    let unstaker = tryGetString("address_"+address+"_asset_"+asset+"_unstaker")
    let realCaller = i.caller.toString()
    if unstaker != realCaller then throw("It seems duck was staked throuh a dapp, not directly, please unstake through dapp!") else 
    if (assetFarmingPower <= 0) then {
      throw("asset not available")
    } else {
      let isWithoutPerch = tryGetBoolean("address_"+address+"_asset_"+asset+"_without_perch")
      if (color == "U") then {
        throw("use another function to unstake Jackpot NFT")
      } else {

        let result = getUnstakeResult(address, assetId, assetRewardDelta, reward, assetFarmingPower)
        let appendPerches = if isWithoutPerch then [DeleteEntry("address_"+address+"_asset_"+asset+"_without_perch")] else [IntegerEntry("address_"+address+"_perchesAvailable_"+color, tryGetInteger("address_"+address+"_perchesAvailable_"+color) + 1)]
        (result ++ [
          ScriptTransfer(i.caller, reward * 1000000, getEggAssetId()),
          ScriptTransfer(i.caller, 1, assetId)
        ]++appendPerches, reward * 1000000)

      }
    }
  }
}

@Callable(i)
func stakeJackpot(color: String) = {
  if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let pmt = i.payments[0].value()
    let assetId = pmt.assetId.value()
    let address = i.originCaller.toString()
    let availablePerches = tryGetInteger("address_"+address+"_perchesAvailable_"+color)

    let assetIssuer = assetInfo(assetId).value().issuer

    if (pmt.amount != 1) then throw("NFT is not attached") else
    if (assetIssuer == getIncubatorAddress() || assetIssuer == getBreederAddress()) then {
      if (assetInfo(assetId).value().name.value().takeRight(1) != "U") then {
        throw("jackpot only")
      } else {
        if (availablePerches <= 0) then {
          throw("no perches available for the color " + color)
        } else {
          let realCaller = i.caller.toString()
          getStakeResult(address, assetId, 100,realCaller) ++ [
            IntegerEntry("address_"+address+"_perchesAvailable_"+color, availablePerches - 1),
            StringEntry("address_"+address+"_asset_"+assetId.toBase58String()+"_perchColor", color)
          ]
        }
      }
    } else {
        throw("asset is not valid")
    }
  }
}

@Callable(i)
func unstakeJackpot(asset: String) = {
  let realCaller = i.caller.toString()
  let address = i.originCaller.toString()
  if (isUserBlacklisted(address)) then {
    throw("Ooops, looks like you lost in one of the Ducksquid games! As you already know, any loss has its consequences, so you will be not able to claim your farming rewards till the end of DuckSquid game. Quack in peace!")
  } else if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let assetId = asset.fromBase58String()
   

    let color = tryGetString("address_"+address+"_asset_"+asset+"_perchColor")

    let assetFarmingPower = getLastKnownAssetFarmingPower(address, asset)

    let assetRewardDelta = calcAssetRewardDelta(address, asset, assetFarmingPower)
    let farmedAmount = assetRewardDelta + tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount")
    let withdrawnAmount = tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount")

    let reward = (farmedAmount - withdrawnAmount) / (scale * 100)
    let unstaker = tryGetString("address_"+address+"_asset_"+asset+"_unstaker")
    if unstaker != realCaller then throw("It seems duck was staked throuh a dapp, not directly, please unstake through dapp!") else 
    if (assetInfo(assetId).value().name.value().takeRight(1) != "U") then {
      throw("jackpot only")
    } else {
      if (assetFarmingPower > 0) then {
        let result = getUnstakeResult(address, assetId, assetRewardDelta, reward, assetFarmingPower)
        let isWithoutPerch = tryGetBoolean("address_"+address+"_asset_"+asset+"_without_perch")
        let appendPerches = if isWithoutPerch then [DeleteEntry("address_"+address+"_asset_"+asset+"_without_perch")] else [IntegerEntry("address_"+address+"_perchesAvailable_"+color, tryGetInteger("address_"+address+"_perchesAvailable_"+color) + 1)]
        (result ++ appendPerches ++ [
          ScriptTransfer(i.caller, reward * 1000000, getEggAssetId()),
          ScriptTransfer(i.caller, 1, assetId)
        ], reward * 1000000)
      } else {
        throw("")
      }
    }
  }
}

@Callable(i)
func claimReward(asset: String) = {
  # throw("under maintence")
  let address = i.originCaller.toString()
  if (isUserBlacklisted(address)) then {
    throw("Ooops, looks like you lost in one of the Ducksquid games! As you already know, any loss has its consequences, so you will be not able to claim your farming rewards till the end of DuckSquid game. Quack in peace!")
  } else if (isLocked() > 0) then {
    throw("EGG operations are temporarily locked")
  } else {
    let assetId = asset.fromBase58String()

    let assetFarmingPower = getLastKnownAssetFarmingPower(address, asset)
    let assetRewardDelta = calcAssetRewardDelta(address, asset, assetFarmingPower)
    
    let farmedAmount = assetRewardDelta + tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount")
    let withdrawnAmount = tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount")

    let reward = (farmedAmount - withdrawnAmount) / (scale * 100)

    if (reward <= 0) then {
      throw("you have no EGGs to withdraw")
    } else {
      ([
        IntegerEntry("address_"+address+"_asset_"+asset+"_withdrawnAmount", tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount") + reward * scale2),
        ScriptTransfer(Address(address.fromBase58String()), reward * 1000000, getEggAssetId())
      ], reward * 1000000)
    }
  }
}

