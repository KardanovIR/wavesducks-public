{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func tryGetStringExternal(address: Address, key: String) = {
    match getString(address, key) {
        case a:String => a
        case _ => ""
    }
}

func tryGetString(key: String) = {
    tryGetStringExternal(this,key)
}

func tryGetIntegerExternal(address: Address, key: String) = {
    match getInteger(address, key) {
        case b:Int => b
        case _ => 0
    }

}

func tryGetInteger (key: String) = {
    tryGetIntegerExternal(this, key)
}

func asInt(value: Any) = match value {
  case int: Int => int
  case _ => throw("RAI: wrong type, expected: Int")
}

func getOracle() = Address(tryGetString("static_oracleAddress").fromBase58String())
func getHuntAddress() = Address(tryGetString("static_huntAddress").fromBase58String())
func getBreederAddress() =  Address(tryGetStringExternal(getOracle(),"static_breederAddress").fromBase58String()) #base58'3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb'



#variables needed
func getDuckOwnerKey(duck: String) = { "duck_"+duck+"_owner"} 
func getDuckStatusKey(duck: String) = { "duck_"+duck+"_status"}
func getDuckRentedByKey(duck: String) =  { "duck_"+duck+"_rentedBy"}
func getDuckDurationKey(duck: String) =  { "duck_"+duck+"_duration"}
func getDuckRentstartKey(duck: String) =  { "duck_"+duck+"_start_ts"}
func getDuckPercentageKey(duck: String) =  { "duck_"+duck+"_percentage"}
func getDuckLastPaidKey(duck: String) =  { "duck_"+duck+"_lastPaid"}

#Variables needed from hunt sc
func keySpotsBought(addressStr: String) = "address_" + addressStr + "_spotsBought"
func keySpotsBusy(addressStr: String) = "address_" + addressStr + "_spotsBusy"

#User needs to be able to stake a duck and put it up for renting
## User needs to have at least free AR glass/staked duck. When no free AR glass, the duck can not be rented out by someone for AR.
## User defines duration to rent out his duck
## User needs to define royalty %
## Payment = duck
## Store on chain = percentage, duration, owner, status=idle,rented
@Callable(i)
func putForRent(durationInMs: Int, percentage: Int) = {
  #Check for attached duck
  let firstPayment = i.payments[0].value()
  let duckId = firstPayment.assetId.value().toBase58String()
  if (firstPayment.amount != 1) then throw("RPFR: NFT is not attached") else
  strict children = invoke(getBreederAddress(),"validateAndGetChildren",[duckId],[]).asInt()
  #Check if owner has free AR-glasses
  let boughtSpots = tryGetIntegerExternal(getHuntAddress(),keySpotsBought(i.caller.toString()))
  let busySpots = tryGetIntegerExternal(getHuntAddress(),keySpotsBusy(i.caller.toString()))
  if boughtSpots <= busySpots then throw("RPFR: No free spots!") else 
  #Store data on chain
  #let endTimeStamp = lastBlock.timestamp+durationInMs
  if (percentage > 80 || percentage < 5) then throw("RPFR: please pick a percentage between 5 and 80%") else 
  [
    IntegerEntry(getDuckPercentageKey(duckId),percentage),
    IntegerEntry(getDuckDurationKey(duckId),durationInMs),
    StringEntry(getDuckOwnerKey(duckId),i.caller.toString()),
    StringEntry(getDuckStatusKey(duckId),"IDLE")
  ]
}


#User needs to be able to claim his duck back
## 1) After duration is over user need to be able to claim duck back
## 2) After duck didnt get rewards for 3000 blocks
## User received duck
## Status from rented = put false, rentedby who = null

@Callable(i)
func claimDuckBack(duckId: String)={
  #Check if duckId is owned by the person
  #Check if duck is IDLE or rented out
  #If rented out, check duck last payment
  #If last payment was within 3000 min, then throw error, else unstake + claimback
  []

}


#Profits for duck need to be topped up #USE FOLD
## Profits need to be shared between owner and renter according by %
## Games payout directly to rent sc?
@Callable(i)
func topUpRewards(duckIds: String, Amounts: String, assetId: String)={
  #Split dudckId based on ;
  #plit qmounts based on ;
  #Loop (fold) through 10 items
  #Get percentage for each duck
  #Split profits between owner and lessor
  #Create transfer transactions for the funds
  []

}

#User need to be able to rent a duck from a user
#User need to select a game to put it in, in this case it will only be HUNT to start with
#Duration from renting is started
#Duck shows for user in te selected game
@Callable(i)
func rentDuckFromUser(duckId: String, game: String)={
  #Check if duck that user wants to rent is IDLE status
  #Check that owner has free spots
  #Check if selected game is HUNT
  #Set start timestamp renting
  #Set status to "RENTED"
  #Stake duck in duckHunt
  
  []
}


@Callable(i)
func configureOracle(oracle: String) = {
  if i.caller != this then throw("RCO: admin only") else 
  [
    StringEntry("static_oracleAddress",oracle)
  ]

}